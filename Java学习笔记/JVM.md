# JVM

## 一、JVM简介

### 1.1 主流虚拟机

+ Hotspot虚拟机，是现在Sun/Oracle JDK以及OpenJDK默认的java虚拟机，也是目前使用最为广泛的java虚拟机
+ JRockit虚拟机，专注于服务端应用，可以不太关注程序的启动速度，JRockit内部不包含解释器，全部代码都是靠即时编译器编译后执行
+ J9虚拟机，J9虚拟机是IBM公司研发的一款JVM，在设计上全面考虑服务端，桌面应用，再到嵌入式的多用途虚拟机，在市场上的定位与Hotspot相似

### 1.2 JVM结构

以Hotspot虚拟机为例，之后的笔记都是基于Hotspot虚拟机的

![JVM结构简图](C:\Users\86198\Desktop\JavaEE\Java八股\JVM结构简图.jpg)

JVM的结构大致分为：类加载子系统、运行时数据区、执行引擎以及本地方法接口

Java代码的执行流程：

+ （1）编写Java源代码，创建一个个.java源文件
+ （2）.java文件经过编译器编译生成.class字节码文件
+ （3）.class文件在Java虚拟机中执行

实际上，上面的图还能够进一步做详细的展开

![JVM结构详细图](C:\Users\86198\Desktop\JavaEE\Java八股\JVM结构详细图.jpg)

之后的介绍都是以上面的图为基准进行

## 二、类加载子系统

### 2.1 概述

Java虚拟机把描述类的数据从Class文件加载道内存，并堆数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称为类的加载机制

类加载子系统的作用就是负责从文件系统或者网络中加载class文件，这包括三个阶段：加载（Loading）、链接（Linking）、初始化（Initialization）

### 2.2 类加载过程 --- Loading阶段

Loading阶段是整个类加载过程中的一个阶段，在这个阶段中，Java虚拟机需要完成三件事情：

+ （1）通过一个类的全限定类名来获取定义此类的二进制字节流
+ （2）讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
+ （3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口

其中，第一步获取定义类的二进制字节流并没有指明二进制字节流必须得从某个class文件中获取，通常来自于：

（1）从ZIP压缩包中获取，这种方式最重成为了日后JAR、EAR，WAR打包格式的基础

（2）重网络中获取

（3）运行时计算生成，常见的应用有动态代理

（4）...还有很多

总结起来一句话：加载阶段，JVM讲Java类的字节码文件加载道机器内存中，并在内存中构建出Java类的原型 --- 类模板对象

### 2.3 类加载过程 --- Linking阶段

链接阶段又分为三步：验证（Verify）、准备（Prepare）、解析（Resolver）

**验证**

验证阶段是链接的第一步，这一步的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全

验证阶段也需要做很多的工作，比如

+ 文件格式验证，验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理；
+ 元数据验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求；
+ 字节码验证，通过数据流分析和控制流分析，确定程序语义是否合法，符合逻辑；
+ 符号引用验证，验证该类是否缺少或者被禁止访问它的某些外部类、方法、字段等资源，目的是确保之后的解析阶段能够正常运行、

**准备**

准备阶段正式为类中定义的变量（静态变量）分配内存并设置类变量初始值的阶段

需要注意的是在这个阶段进行内存分配的仅包括类变量，而不包括实例变量（即普通的成员变量）；设置的初始值是Java类型默认的初始值，比如int类型是0等

但也有特殊的情况，如果静态变量被final修饰，即final static，那么在准备阶段变量值就会被初始化为所赋的常量值

特别的对于String类来说

```java
//如果是使用字面量的方式直接进行赋值，那么会在准备阶段就给s1赋值
static final String s1 = "CONST";   
//但如果是使用new的方式进行赋值，那么会在之后的初始化阶段对s2进行赋值
static final String s2 = new String("const");
```

**解析**

解析阶段是Java虚拟机讲常量池中的符号引用替换为直接引用的过程

+ **符号引用**：是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位道目标即可
+ **直接引用**：是可以直接指向目标的指针，相对偏移量或者是一个能够间接定位道目标的句柄，如果有了直接引用，那么引用的目标一定已经在虚拟机中存在

解析动作主要针对于类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符这7类符号引用进行

### 2.4 类加载过程 --- Initialization阶段

初始化阶段是类加载过程的最后一个步骤，初始化阶段需要做的工作就是就是执行类构造器`<clinit>()`方法的过程

`<clinit>()`方法是由编译器自动收集类中所有的类变量的赋值动作和静态语句块(static{})中的语句合并产生的

`<clinit>()`方法与类的构造函数（`<init>()`）方法不同，它不需要显示地调用父类构造器，Java虚拟机会保证子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕，这里也能够看出来，Java虚拟机执行的第一个`<clinit>()`方法一定是java.lang.Object

Java虚拟机必须保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步



### 2.5 类加载器

在Loading阶段，其中一个重要的步骤是通过一个类的全限定类名来获取定义此类的二进制字节流，Java虚拟机在设计的时候，有意把这个步骤放到Java虚拟机的外部去实现，以便让程序自己决定如何去获取所需要的类，实现这个动作的代码被称为“类加载器” --- ClassLoader

从Java虚拟机的角度看，存在两种不同类型的类加载器：**引导类加载器（bootstrap classloader）**和其他类加载器

> 这个其他类加载器指的是继承于抽象类ClassLoader的类加载器

但在实际上的loading阶段的过程来看，可以将上面的分类再具体划分，分为引导类加载器、**扩展类加载器（Extension classloader）**和**应用程序类加载器（Application classloader）**

+ **引导类加载器**，这个类加载器是使用C++语言实现，是虚拟机自身的一部分，主要负责加载存放再`<JAVA_HOME>\lib`目录下并且能被Java虚拟机识别的类（主要是Java核心库，加载的包名通常以java.，javax.，sun.开头）

  这个类加载器无法被Java程序直接引用，使用`java.lang.ClassLoader`包下的`getClassLoader()`方法获取这个系统类加载器时，获取到的是null；当开发人员在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去加载，那么直接用null代替即可

+ **扩展类加载器**，这个类加载器使用Java语言编写，继承于ClassLoader类，需要使用bootstrap classloader加载到内存中，主要负责加载`<JAVA_HOME>\lib\ext`目录中，或者被`java.ext.dirs`系统变量所指定的路径中的类

## 三、运行时数据区





## 四、执行引擎

