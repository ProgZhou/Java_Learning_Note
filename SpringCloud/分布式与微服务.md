# 分布式与微服务

## 一、分布式基础理论

### 1.1 什么是分布式系统

分布式系统是若干个独立计算机的集合，这些计算机对于用户来说就像单个相关系统

分布式系统是建立在网络之上的软件系统

分布式系统由一组完成共同任务而协调工作的计算机结点组成，它们通过网络进行通信

**为什么要有分布式系统**

随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已经无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进

分布式系统能满足互联网对大数据存储、高并发和快响应的要求，采用了分而治之的思想

+ **高性能：**因为大量请求被合理地分摊到各个节点，使每一台Web服务器的压力减小，并且多个请求可以使用多台机器进行处理，所以能处理更多的请求和数据，性能更高
+ **高可用：**在单机系统中，机械故障会造成网站不可用，但在分布式中，如果某个结点出现故障，系统会自动发现这个故障，不再向这个结点转发请求，系统仍然可以工作
+ **可伸缩性：**当现有机器的性能不能满足业务的发展时，就需要更多的机器提供服务，只要改造路由算法，就能够路由到新机器，从而将更多的机器容纳到系统中，继续满足大数据，高并发和快响应的要求
+ **可维护性：**如果设备当中有一台机器因某种原因不能对外提供服务，如机器出现故障，此时只需要停止那些出现故障的结点，对其进行处理并再次上线即可

### 1.2 应用架构发展演变

发展历程：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\分布式架构的由来.jpg)

**单一应用架构：**当网站流量很小时，只需要一个应用，将所有功能都部署在一起，以减少部署结点和成本，此时用于简化增删改查工作量的数据访问框架(ORM)是关键

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\单一应用架构.jpg)

单一应用架构的缺点：

+ 扩展难，对应用某个功能的修改需要将整个应用重新打包部署
+ 协同开发不容易，不易维护
+ 当应用逐渐扩大，单台服务器跑整个应用性能会逐渐下降

**垂直应用架构：**将完整的应用拆分成几个独立的小应用，每一个应用都是独立完整的，每一个应用单独部署到同一台服务器上，这样解决了单一架构扩展难以及协同合作困难的问题

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\垂直应用架构.jpg)

垂直应用架构的缺点：

+ 界面与业务逻辑实现分离，如果只修改界面，会导致一个完整的应用重新部署
+ 应用不可能完全独立，大量的应用之间需要交互

**分布式服务架构：**将各个应用的核心业务单独抽取出来，这样就解决了前后端分离的问题，如果仅修改界面，无需将业务逻辑层的功能重新部署

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\分布式服务架构.jpg)

RPC：远程过程调用

**流动计算架构：**解决分布式服务架构存在的负载均衡的问题，即合理的分配服务器资源

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\流动计算架构.jpg)

**分布式服务所出现的问题**

+ 异构的机器与网络：在分布式服务中，每一台服务器的硬件配置都是不相同的，如何让多台机器为同一个业务目标服务，这是一个相当复杂的问题
+ 普通结点的故障：在分布式系统中，如果某些机器因为自身原因发生故障，那么整个系统如何去发现它们，并将它们剔除出去。使得请求能够到达正常工作的结点
+ 不可靠的网络和机器：多台服务器之间是通过网络进行交互的，网络传输必然发生延时，丢包等网络传输问题；每台服务器也会因为请求量的增加而导致处理服务的能力降低，如何解决这些问题也是分布式系统所面临的挑战

总结来说，因为网络与服务器的众多不确定性，注定了分布式的难点在于，如何让多个结点之间保持一致性，因为**数据一致性问题是分布式的核心问题之一**



### 1.3 RPC



+ RPC基本原理：服务器之间建立网络连接

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\RPC基本原理.jpg)

+ RPC示例：AB之间需要建立连接，传输数据需要将数据进行**序列化和反序列化**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\RPC示例.jpg)

RPC的两个核心模块：通讯和序列化

### 1.4 CAP理论

- **一致性（Consistency）** : 所有节点访问同一份最新的数据副本，保持所有结点在同一时刻具有相同的，逻辑一致的数据
- **可用性（Availability）**: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。保证每个请求不管成功还是失败都有响应
- **分区容错性（Partition tolerance）** : 分布式系统出现网络分区的时候，仍然能够对外提供服务。

CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，**最多只能同时较好的满足两个**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\CAP理论.jpeg)

因此，根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类

+ CA：单点集群，满足一致性，可用性，通常在可扩展性上不太强大

+ CP：满足一致性，分区容忍性的系统，通常性能不是特别高

+ AP：满足可用性，分区容错性的系统，通常可能对一致性的要求低一些

CAP理论就是说在分布式存储系统中，最多只能实现上面的两点，而由于当前的网络硬件肯定会出现延迟丢包等问题，所以**分区容错性必须要实现**

CA传统的关系型数据库

AP大多数网站架构的选择

CP Redis、Mongdb等非关系型数据库

CAP理论关注粒度是数据，而不是整体系统设计的策略



### 1.5 BASE理论

在如今现实的业务中，金额和商品的库存数据是企业生产的核心数据，在分布式系统中保证这些数据的一致性，是分布式系统的核心任务之一，但根据CAP理论来看，保持一致性的同时，可能会给系统带来复杂性和性能的丢失

BASE理论的核心思想是：即使分布式系统无法保证强一致性，也可以采用适当的方法达到最终一致性

在BASE理论中，一致性分为强一致性和弱一致性

+ 强一致性：当用户完成数据更新操作之后，任何后续线程或者其他结点都能访问到最新值
+ 弱一致性：当用户完成数据更新操作之后，并不能保证后续线程或者其他结点马上访问到最新的值

BASE理论并非一个单词，而是几个英文单词的缩写：

+ **BA（Basically Available）：基本可用**，在分布式系统中，最重要的需求就是保证基本可用，有响应结果返回；比如在双十一抢购的高并发苛刻的环境下，即使抢购失败也会返回“系统繁忙”的提示
+ **S（Soft State）：软状态**，其意义在于允许系统存在中间状态，一般来说系统之间的数据通信都会存有副本，而这些副本都会存在一定的延迟，这时，推荐使用弱一致性代替强一致性，这样的好处在于，提高系统的可用性和性能
+ **E（Eventual Consistency）：最终一致性**，指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，以保证数据的正确性

BASE理论的应用场景是大型分布式系统，**它的核心内容是放弃强一致性，保证系统的可用性**，它建议让数据在一段时间内不一致，从而降低计数实现的复杂性，并提高系统的性能，最后再通过某种手段使得数据达成最终一致

## 二、微服务架构

### 2.1 什么是微服务架构

微服务架构是近几年来最流行的分布式架构

微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调，互相配合，为服务提供最终价值，每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作（通常是基于HTTP协议的RESTful API）；每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境。类生产环境等等，另外，应当尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建

#### 2.1.1 为什么会出现微服务架构

这就需要提到单一服务架构的弊端

单一服务架构一般分为用户接口，服务端应用和数据源，因为它们是一个整体，所以如果当中的某个业务模块发生了变化或者出现了bug，就需要重新构建和部署，随着时间的积累，各个业务模块很难保持很好的模块化结构，很容易出现一个业务模块影响别的业务模块的情况：

+ 从扩展性上看，扩展任何模块都需要扩展整个单体服务，而不能部分扩展；
+ 从部署和维护的角度来看，任何扩展和修正都需要重新升级所有服务，做不到部署和维护单个模块；
+ 从业务角度来看，随着业务的复杂化，系统模块之间的耦合也会日趋严重

而微服务架构只是将一个单体应用程序拆分为多个相对独立的服务，每一个服务都拥有独立的进程和数据，每一个服务都是以轻量级的通信机制进行交互的，一般为HTTP API，因此每一个微服务都可以独立地自动化部署和维护，这样就更有利于程序员进行粒度更小的开发

**微服务和分布式的关系**

微服务是分布式系统设计和架构的理念之一，但并不是为了克服所有的分布式系统的缺陷而设计的，微服务并不能解决所有分布式系统存在的问题，只是寻求一个平衡点，让架构师能够更加简单、容易的构建分布式系统



#### 2.1.2 微服务的风格

+ **组件化和服务：**可以将一个单体应用拆分成一个个可以单独维护和升级的软件单元，每一个单元就称为组件

  每一个组件能够运行在自己的独立进程里，可以调用自己内部的方法来完成自身独立的业务功能；但是更多的时候组件之间需要相互协调才能完成完整的业务，这就需要通过服务来完成了，这里的服务指的是进程外的组件，它允许我们调用其他的组件，并且服务一般会以明确的通信机制提供，比如http协议，Web Service或者远程过程调用（RPC）

+ **强化终端及弱化通道：**微服务的引用致力于高内聚，低耦合的目标，也就是业务模块的划分具有高内聚的特点，而各个业务组件则呈现出松耦合的特点；系统拆分之后，需要各个组件相互协调才能完成任务，因此各个组件之间需要相互通信，这就需要引入各种各样的通信协议，在微服务的架构中，建议弱化通信协议的复杂性，常用的是一下两种：

  + 包含资源API的HTTP的请求-响应和轻量级消息通信协议，比如REST风格
  + 用轻量级的消息总线来发布消息，如RabbitMQ

+ **分散治理：**微服务架构中的每一个组件所面对的业务焦点都是不一样的，不同的业务组件也许需要不同的语言进行开发，而微服务架构允许我们使用各类语言构建组件，各个组件之间只需要约定号服务接口即可

+ **分散数据管理：**微服务架构建议使用分散的数据管理，也就是每一个组件都应该有自己的数据源，包括数据库和NoSQL，这样就可以按照微服务组件划分的规则，划分对应的数据，有助于更精确的数据管理

+ **基础设施自动化：**由于微服务将一个单体系统拆分为多个组件，这样就会造成多个组件的测试和部署，在业务不断扩大的情况下，会加重运维人员的工作负担，可以使用现有的云计算，Docker等技术来减轻测试，构建和发布的复杂性



### 2.2 什么是SpringCloud

SpringCloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶

SpringCloud所包含的技术内容：

+ 服务注册与发现
+ 服务调用
+ 服务熔断
+ 负载均衡
+ 服务降级
+ 服务消息队列
+ 配置中心管理
+ 服务网关
+ 服务监控
+ 全链路追踪
+ 自动化构建部署
+ 服务定时任务调度操作

### 2.3 SpringCloud组件

SpringCloud组件的迭代更新

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Cloud组件.jpg)





### 2.4 创建一个Cloud工程

#### 2.4.1 微服务Cloud整体聚合父工程

创建一个maven的父工程

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\新建父工程.jpg)

修改pom文件，仲裁一些jar的版本，以及引入一些基本的jar包

```xml
<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.SpringCloud</groupId>
  <artifactId>JavaSpringCloud</artifactId>
  <version>1.0-SNAPSHOT</version>
  <modules>
    <module>springcloud-payment</module>
      <module>springcloud-order</module>
      <module>springcloud-api-commons</module>
  </modules>

  <packaging>pom</packaging>
  <!-- packaging pom 总工程-->
  <!--统一管理jar包版本-->
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <junit.version>4.12</junit.version>
    <lombok.version>1.18.10</lombok.version>
    <log4j.version>1.2.17</log4j.version>
    <mysql.version>5.1.47</mysql.version>
    <druid.version>1.1.16</druid.version>
    <mybatis.spring.boot.version>1.3.0</mybatis.spring.boot.version>
  </properties>

  <!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version-->
  <dependencyManagement><!--定义规范，但不导入-->
    <dependencies>
      <dependency>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-project-info-reports-plugin</artifactId>
        <version>3.0.0</version>
      </dependency>
      <!--spring boot 2.2.2-->
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.2.2.RELEASE</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!--spring cloud Hoxton.SR1-->
      <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>Hoxton.SR1</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!--spring cloud 阿里巴巴-->
      <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-alibaba-dependencies</artifactId>
        <version>2.1.0.RELEASE</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!--mysql-->
      <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>${mysql.version}</version>
        <scope>runtime</scope>
      </dependency>
      <!-- druid-->
      <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>${druid.version}</version>
      </dependency>
      <!--mybatis-->
      <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>${mybatis.spring.boot.version}</version>
      </dependency>
      <!--junit-->
      <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>${junit.version}</version>
      </dependency>
      <!--log4j-->
      <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>${log4j.version}</version>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <!--热启动插件-->
  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <fork>true</fork>
          <addResources>true</addResources>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

创建完成之后的父工程：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\SpringCloud父工程.jpg)

#### 2.4.2 构建微服务模块

**每一个微服务的模块构建都是遵循如下步骤：**

1. 新建Module（微服务子模块）
2. 修改pom文件
3. 编写yml配置文件
4. 编写著启动类
5. 写业务逻辑

新建一个微服务的提供者：springcloud-payment模块

按照父工程的创建过程创建子模块，并且按照上述的构建模块的步骤进行后续过程

**修改pom文件：**引入项目需要的一些依赖，如果是父工程中的版本，可以不写版本号；如果需要与父工程定义版本不一致的jar，需要写版本号

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>JavaSpringCloud</artifactId>
        <groupId>com.SpringCloud</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>springcloud-payment</artifactId>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.SpringCloud</groupId>
            <artifactId>springcloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
		<!--版本与父工程中定义的版本不同，需要明确地指出所需要的版本号-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.21</version>
        </dependency>

        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.16</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <fork>true</fork>
                    <addResources>true</addResources>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

**编写yml配置文件：**主要配置一些基础参数，比如服务端口，服务名称，数据源等等

```yml
server:
  port: 8001
spring:
  application:
    name: cloud-payment-service

  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springcloud?serverTimezone=GMT%2B8&characterEncoding=utf-8
    username: root
    password: 123456
  jackson:
    time-zone: GMT+8
    date-format: yyyy-MM-dd HH:mm:ss

#mybatis配置文件所在的位置
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.SpringCloud.entities
```

**编写启动类：**编写springboot的启动类

```java
@SpringBootApplication
public class PaymentMain {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain.class, args);
    }
}
```

**编写业务逻辑：**一些基本的增删改查



经过上述步骤的创建，就新建了一个微服务的模块，之后根据业务的需要再新建其他微服务模块

#### 2.4.3 服务之间的测试

在上述的过程中创建了一个微服务的提供者，springcloud-payment，提供支付的接口

下面再创建一个微服务子模块，调用payment的接口进行一些操作 -- springcloud-order，遵循上述创建子模块的步骤

springcloud-order模拟的是用户端口，仅需要根据需求访问springcloud-payment的端口即可，所及结构也比较简单

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\用户微服务模块.jpg)

值得注意的是，order模块的controller层需要向payment模块发送请求，而不再像之前一样仅向服务内部发送请求并处理

```java
//Order模块下的controller层
@RestController
public class OrderController {

    public static final String PAYMENT_URL = "http://localhost:8001";

    @Resource
    private RestTemplate restTemplate;

    @GetMapping("/consumer/payment/add")
    public CommentResult<Payment> create(Payment payment){
        return restTemplate.postForObject(PAYMENT_URL + "/payment/add", payment, CommentResult.class);
    }


    @GetMapping("/consumer/payment/get/{id}")
    public CommentResult<Payment> getPayment(@PathVariable("id") Long id){
        return restTemplate.getForObject(PAYMENT_URL + "/payment/get/" + id, CommentResult.class );
    }
}
```



**抽取公共部分：**每个模块可能会有一些组件的代码是相同的，所以，可以新建一个模块将这些公共部分的代码存起来，供其他微服务模块进行调用

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\公共部分.jpg)

再将这些部分以maven依赖的方式导入到各个模块中

```xml
<dependency>
    <groupId>com.SpringCloud</groupId>
    <artifactId>springcloud-api-commons</artifactId>
    <version>${project.version}</version>
</dependency>
```



**最后，测试模块之间的调用：**启动order模块和payment模块的服务器，由order端向payment端发送请求

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\发送请求-查询.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\发送请求-增加.jpg)

### 2.5 服务注册中心

#### 2.5.1 Eureka

**1、什么是服务治理和服务注册**

服务治理：在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。

 Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理



服务注册与发现：Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他c微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka架构.jpg)

在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息，比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用，RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))

**2、Eureka的两个组件**

Eureka Server和Eureka Client

Eureka Server提供服务注册服务
各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

EurekaClient通过注册中心进行访问
是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）

**3、构建Eureka服务端**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka服务端构建.jpg)

pom文件需引入一个新的组件：

```xml
<!--eureka-server-->
        <dependency>           
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
```

在application.yml文件中新添加配置：

```yml
eureka:
  instance:
    hostname: localhost #eureka服务端的实例名称
  client:
    #false表示不向注册中心注册自己。当然也可以将Eureka服务端注册到注册中心中，只不过没有必要
    register-with-eureka: false
    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-registry: false
    service-url:
    #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

在主启动类上除了添加@SpringbootApplication注解之外，需要再添加一个@EnableEurekaServer注解

```java
@SpringBootApplication
@EnableEurekaServer   //代表这是一个Eureka注册中心
public class EurekaMain {
    public static void main(String[] args) {
        SpringApplication.run(EurekaMain.class, args);
    }
}
```

**4、将一个微服务注册到Eureka服务端**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\注册到Eureka服务端.jpg)

修改springcloud-payment的pom文件，主要是添加一个组件：

```xml
<!--Eureka客户端-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

修改application.yml配置文件，主要是添加一项配置：

```yml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      defaultZone: http://localhost:7001/eureka
```

最后在主启动类上添加@EnableEurekaClient注解，表明这是一个Eureka的客户端

```java
@SpringBootApplication
@EnableEurekaClient   //表明是一个Eureka客户端
public class PaymentMain {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain.class, args);
    }
}
```

最终测试结果：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka服务注册中心.jpg)

可以看到在Instances currently registered with Eureka这一栏中有一个微服务被注册进来了，服务的别名是CLOUD-PAYMENT-SERVICE

#### 2.5.2 Eureka集群

**1、Eureka集群原理**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka集群原理.jpeg)

微服务远程调用RPC最核心的是高可用，如果只有一个服务注册中心在运行，那么当这个注册中心的服务宕机了，就会导致整个微服务环境宕机

解决办法：搭建Eureka注册中心集群 ，实现**负载均衡+故障容错**

**2、Eureka集群搭建**

再新建一个eureka-server7002，根据之前创建的eureka-server7001步骤创建，创建完毕后修改pom文件

```xml
<dependencies>
        <!--eureka-server-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
        <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
        <dependency>
            <groupId>com.atguigu.springcloud</groupId>
            <artifactId>cloud-api-commons</artifactId>
            <version>${project.version}</version>
        </dependency>
        <!--boot web actuator-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--一般通用配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
        </dependency>
    </dependencies>

```

修改映射配置，由于现在不再是只有一个注册服务的环境下，为了区分各个不同注册服务，需要修改Windows的系统映射配置

```
##############SpringCloud#############
127.0.0.1        eureka7001.com
127.0.0.1        eureka7002.com
```

修改yml配置文件：

```yml
#同理，在修改了新创建的eureka7002后，同样需要修改eureka7001端的yml配置
server:
  port: 7002

eureka:
  instance:
  	#在之前单注册中心的环境下，这里写的是localhost
    hostname: eureka7002.com #eureka服务端的实例名称
  client:
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: false     #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    service-url: 
      #当采用eureka注册集群时，集群中的每个注册服务需要遵循相互注册的原则，即中心中的每一个服务需要注册到其他注册服务当中去
      defaultZone: http://eureka7001.com:7001/eureka/
```

最后编写主启动类

**3、将微服务注册到eureka集群中**

先将payment8001注册到集群中，只需要修改yml的配置即可

```yml
eureka:
  client:
    #表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      #defaultZone: http://localhost:7001/eureka  之前的单机版仅需要注册到一个注册服务中
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版
```

按照相同的步骤可以将order80也注册到eureka集群中

**4、微服务提供者集群搭建**

观察eureka的架构图可以发现，微服务的提供者也多数是集群的方式，所以需要将微服务提供者集群也注册到eureka集群中

先新另一个payment8002，可以照搬payment8001

修改两个payment的controller的代码

```java
//增加一个端口号，更清晰的显示微服务消费者的请求被哪个微服务提供者处理
@Value("${server.port}")
private String serverPort;
```

在将多个微服务提供者注册到eureka集群中后，需要修改消费者的请求地址，在之前单机模式下，由于微服务只有一个，所以可以将请求地址写死，但现在，有了多个微服务的提供者，为了达到负载均衡，需要灵活地挑选请求地址

```java
//单个微服务状态下的URL访问地址
    //public static final String PAYMENT_URL = "http://localhost:8001";
    //当有多个微服务时，集群访问需要灵活选择访问地址做到负载均衡
    public static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE";
```

但仅仅是这样，会出现http://CLOUD-PAYMENT-SERVICE Not support的错误，这是由于直接做这样的修改，注册中心中有多个同名的服务，不知道具体该选哪一个，所以在配置类中，注册RestTemplate的时候，要加上负载均衡的注解

```java
@Configuration
public class ApplicationContextConfig {
    @Bean
    @LoadBalanced  //开启RestTemplate的负载均衡功能，默认使用轮询的算法
    public RestTemplate getTemplates(){
        return new RestTemplate();
    }
}
```

**5、测试**

在启动服务的时候，先启动注册中心中的服务，再启动服务提供者的服务，最后启动消费者的服务

eureka注册中心界面：可以看到注册中心的cloud-payment-service中注册了两个微服务

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka集群.jpg)

使用消费者端order访问payment的查询服务，第一次访问由payment8001处理，第二次访问由payment8002处理，依次类推

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\负载均衡轮询访问1.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\负载均衡轮询访问2.jpg)

#### 2.5.3 Eureka服务发现

对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息，观察eureka的监控界面

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka服务注册中心.jpg)

在Instance currently registered with Eureka是所有在当前注册中心下注册的微服务的ServiceId，它与每个微服务提供者yml配置下的application name相对应

```yml
spring:
  application:
    name: cloud-payment-service
```

对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息，修改payment8001的controller层

```java
@RestController
@Slf4j
public class PaymentController
{
    //一些必要属性
    ...
	
    //新增一个类来获取注册中心中的服务
    @Resource
    private DiscoveryClient discoveryClient;
	//一些业务逻辑的实现
   ...

    //服务发现
    @GetMapping(value = "/payment/discovery")
    public Object discovery()
    {
       //获取注册中心中的所有serviceId，即Instance currently registered with Eureka中Application列的内容
        List<String> services = discoveryClient.getServices();
        for (String element : services) {
            System.out.println(element);
        }
		//根据serviceId获取每个具体的微服务内容
        List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
        for (ServiceInstance element : instances) {
            System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t"
                    + element.getUri());
        }
        return this.discoveryClient;
    }
}
 
```

#### 2.5.4 Eureka自我保护机制

保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。

**为什么会产生Eureka自我保护机制？**
为了防止EurekaClient可以正常运行，但是与 EurekaServer网络不通情况下，EurekaServer会立刻将EurekaClient服务剔除的问题

**什么是自我保护模式？**
默认情况下，如果EurekaServer在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。

在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。
它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Eureka自我保护机制.jpeg)

**一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存**

#### 2.5.5 Zookeeper

zookeeper是一个分布式协调工具，可以实现注册中心功能

**SpringCloud整合Zookeeper代替Eureka**

1、新建springcloud-payment8004

2、修改pom文件

```xml
 <!-- SpringBoot整合zookeeper客户端 
	主要是将之前的eurekaServer的服务器替换成springcloud下整合zookeeper的整合包
-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
        </dependency>
<!--
需要注意的是，这个整合包自带默认的zookeeper的版本，3.4.5 beta
需要替换成本机上的zookeeper版本
-->
<!--先排除自带的zookeeper-->
            <exclusions>
                <exclusion>
                    <groupId>org.apache.zookeeper</groupId>
                    <artifactId>zookeeper</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!--添加zookeeper3.4.9版本-->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.5.9</version>
        </dependency>
```

3、编写yml文件

```yml
server:
  port: 80
spring:
  application:
    name: cloud-order-consumer
  cloud:
    zookeeper:
      #zookeeper的连接地址
      connect-string: 192.168.43.126:2181
```

在连接zookeeper时，最好在zookeeper的配置文件中配置服务器端的ip，否则有可能出现连接不上的情况

```
# the port at which the clients will connect
clientPort=2181
server=192.168.43.126:2181
```

4、编写主启动类和controller层

5、测试：在zookeeper中查看注册的服务端

启动一个命令行连接zookeeper  zkCli

输入命令 ls / 查看zookeeper注册的全部服务信息，在没有注册的情况下只有默认的zookeeper服务

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\zookeeper客户端.jpg)

查看服务的具体信息

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\查看zookeeper内部服务信息.jpg)

可以发现cloud-payment-servie服务已经注册进zookeeper

以相同的步骤可以将消费者服务注册进zookeeper，并且可以在浏览器端进行访问测试

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\zookeeper访问.jpg)

可以发现服务可以正常运行

要注意的一点是，zookeeper与eureka不同，zookeeper会将在指定时间内没有收到心跳信号的服务立即踢出注册中心

#### 2.5.6 Consul

**什么是Consul**

Consul 是一套开源的分布式服务发现和配置管理系统，由 HashiCorp 公司用 Go 语言开发。

提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。

它具有很多优点。包括： 基于 raft 协议，比较简洁； 支持健康检查, 同时支持 HTTP 和 DNS 协议 支持跨数据中心的 WAN 集群 提供图形界面 跨平台，支持 Linux、Mac、Windows

#### 2.5.7 三个服务注册中心的区别

Eureka：AP理论，保证系统的可用性，而降低对数据一致性的要求；因为Eureka有一个自我保护机制，不会立即将掉线的服务提出注册中心，但这样再次连接上服务时，可能会出现数据的不一致

>  Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\AP理论.jpeg)



zookeeper/consul：CP理论，为保证系统数据的一致性，降低对可用性的要求；zookeeper和consul没有自我保护机制，如果一个服务因网络故障掉线，它们会立即将服务踢出注册中心，不允许客户端再向掉线服务发送请求，从而保证数据的一致性

> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\CP理论.jpeg)

### 2.6 服务调用

#### 2.6.1 Ribbon

**什么是Ribbon**

Spring Cloud Ribbon是基于Netflix Ribbon实现的一套**客户端负载均衡**的工具。

简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用（Ribbon内嵌在客户端中）。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。

**什么是负载均衡**

简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。
常见的负载均衡有软件Nginx，LVS，硬件 F5等。

*Ribbon与Nginx的区别*

` Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。` 

`Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。`

*客户端负载均衡和服务端负载均衡*

> 客户端负载均衡和服务端负载均衡最大的不同点在于上面所提到服务清单所存储的位置。
>
> 在客户端负载均衡中，所有客户端结点都维护着自己要访问的服务端清单，而这些服务端清单来自于服务注册中心，比如Eureka服务端，并且需要心跳去维护服务端清单的健康性
>
> 服务端的负载均衡是当客户端发送请求到负载均衡设备的时候，该设备按某种算法（比如线性轮询、按权重负载、按流量负载等）从维护的可用服务端清单中取出一台服务端端地址，然后进行转发。

Ribbon负载均衡架构

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Ribbon负载均衡.jpeg)

总结：Ribbon其实就是一个软负载均衡的客户端组件，
他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。

spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用

**RestTemplate的使用**

```java
<T> T getForObject(URI URL, Class<T> responseType);   //返回对象为响应体中数据转化成的对象，基本上可以理解为Json
<T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType); //返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等
//post方式相同
```



**Ribbon核心组件：IRule**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\IRule.jpg)

默认使用轮询的算法进行负载均衡，可以做相应的配置进行替换

**Ribbon负载均衡算法原理**

负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标  

*每次服务重启动后rest接口计数从1开始*

```
List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");
 
如：  List [0] instances = 127.0.0.1:8002
　　　List [1] instances = 127.0.0.1:8001
 
8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理：
 
当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001
当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002
当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001
当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002
如此类推......
```



#### 2.6.2 OpenFeign

**什么是OpenFeign**

Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。
它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡

**Feign能干什么**
Feign旨在使编写Java Http客户端变得更容易。
前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

**OpenFeign的使用**

微服务调用接口+@FeignClient

```java
@FeignClient(value = "CLOUD-PAYMENT-SERVICE")  //标识要调用哪个微服务下的接口
public interface PaymentFeignService {
    //调用某个微服务下的Controller的接口方法
    @GetMapping("/payment/get/{id}")
    public CommentResult<Payment> getPaymentById(@PathVariable("id") Long id);

}
```

**OpenFeign超时控制**

默认Feign客户端只等待一秒钟，但是服务端处理客户端的请求需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。
为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。

```yml
#设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间
  ReadTimeout: 5000
#指的是建立连接后从服务器读取到可用资源所用的时间
  ConnectTimeout: 5000
```

**OpenFeign日志打印功能**

Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。
说白了就是对Feign接口的调用情况进行监控和输出

日志级别：

NONE：默认的，不显示任何日志；

BASIC：仅记录请求方法、URL、响应状态码及执行时间；

HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；

FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数

**日志打印功能的使用**

```java
//在配置类中配置日志bean
@Configuration
public class FeignConfig{
    @Bean
    Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}
```

```yml
#在application.yml配置文件中配置日志功能
logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.atguigu.springcloud.service.PaymentFeignService: debug
```

最终效果：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Open.jpeg)

### 2.7 服务降级

服务器雪崩：

多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.

> 服务器雪崩一般是指 主业务不依赖的某些辅助类服务变得不可靠进而导致主业务所调用的核心服务受牵连直至各个上游依赖者连同崩溃的现象。
>
> 假设核心服务1、核心服务2依赖核心服务3，而核心服务3又会调用辅助服务4
>
> ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\服务雪崩.jpg)
>
> 假设某天这个辅助类服务4开始变得不可靠（服务器磁盘IO、网络IO压力过大、宕机等），导致响应时间变长，那么这时候核心服务3的服务器对于辅助服务4的请求就有可能会越积越多，这样就会导致核心服务3的响应也一并开始变慢，而核心服务1、核心服务2也强依赖于核心服务3，这样就会出现一个无关核心业务的辅助类服务就影响了整个系统的可用。

区分概念：

+ **服务降级**：当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。

  > 比如访问网站时，出现"服务器忙，请稍后再试"的页面，不让客户端等待并立刻返回一个友好提示，fallback

  触发服务降级的几种情况：

  + 程序运行异常
  + 服务器处理超时
  + 发生服务熔断
  + 线程池，信号量打满，没有新线程分给服务

+ **服务熔断**：在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。

  > 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示
  >
  > 熔断不可能是永久的，当经过了规定时间之后，服务将从熔断状态回复过来，再次接受调用方的远程调用。

+ **服务限流**：秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行

**服务降级的演示：**

新建一个支付服务提供者，springcloud-payment-hystrix-8001，将服务注册进eureka注册中心，编写Controller层和service层

```java
@RestController
@Slf4j
public class PaymentController
{
    @Autowired
    private PaymentService paymentService;

    @Value("${server.port}")
    private String serverPort;


    @GetMapping("/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id)
    {
        String result = paymentService.paymentInfo_OK(id);
        log.info("****result: "+result);
        return result;
    }

    @GetMapping("/payment/hystrix/timeout/{id}")
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id) throws InterruptedException
    {
        String result = paymentService.paymentInfo_TimeOut(id);
        log.info("****result: "+result);
        return result;
    }
}
@Service
public class PaymentService
{
    /**
     * 正常访问，一切OK
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id)
    {
        return "线程池:"+Thread.currentThread().getName()+"paymentInfo_OK,id: "+id+"\t"+"O(∩_∩)O";
    }

    /**
     * 超时访问，演示降级
     * @param id
     * @return
     */
    public String paymentInfo_TimeOut(Integer id)
    {
        try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
        return "线程池:"+Thread.currentThread().getName()+"paymentInfo_TimeOut,id: "+id+"\t"+"O(∩_∩)O，耗费3秒";
    }
}
```

使用jmeter进行压力测试，设置20000个线程同时访问http://localhost:8001/payment/hystrix/ok/31

对于结果来说，可以发现，当在这两万个线程访问timeout方法时，当我们再次去访问ok方法，发现这个方法也需要等待一定时间之后才会返回结果

原因：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。

**问题解决**

+ 超时导致服务器变慢，设置超时不再等待，进行服务降级
+ 如果服务器内部出错，宕机或者程序错误，需要设置处理方法

#### 2.7.1 Hystrix

**什么是Hystrix**

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

**Hystrix的使用**

在服务提供者端，也就是cloud-payment-hystrix-8001，添加依赖：

```xml
<!--hystrix-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
```

服务提供者端需要在自己的服务中设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback，@HystrixCommand注解，一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的
fallbackMethod调用类中的指定方法

```java
@Service
public class PaymentService{
    /**
     * 正常访问，一切OK
     * @param id
     * @return
     */
    public String paymentInfo_OK(Integer id){
        return "线程池:"+Thread.currentThread().getName()+"paymentInfo_OK,id: "+id+"\t"+"O(∩_∩)O";
    }

    /**
     * 超时访问，演示降级
     * @param id
     * @return
     */
    //fallbackMethod属性标记兜底的方法，即当服务出错或者超时时，会跳转到指定方法进行处理
    //commandProperties属性设置自身调用的超时时间的峰值，超过这个峰值就进行服务降级处理
    @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler",commandProperties = {
            @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="3000")
    })
    public String paymentInfo_TimeOut(Integer id){
        int second = 5;
        try { 
            TimeUnit.SECONDS.sleep(second); 
        } catch (InterruptedException e) { 
            e.printStackTrace(); 
        }
        return "线程池:"+Thread.currentThread().getName()+"paymentInfo_TimeOut,id: "+id+"\t"+"O(∩_∩)O，耗费秒: "+second;
    }
    
    public String paymentInfo_TimeOutHandler(Integer id){
        return "/(ㄒoㄒ)/调用支付接口超时或异常：\t"+ "\t当前线程池名字" + Thread.currentThread().getName();
    }
}
 
```

在主启动类上标明@EnableCircuitBreaker注解标识启动Hystrix服务熔断

```java
@SpringBootApplication
@EnableEurekaClient
@EnableCircuitBreaker
public class PaymentHystrixMain {
    public static void main(String[] args) {
        SpringApplication.run(PaymentHystrixMain.class, args);
    }
}
```

一般Hystrix服务降级机制是配置在客户端的，客户端访问服务端，如果服务端内部出错或者处理超时，转接到兜底方法，给客户端返回一个提示信息，高速客户端不必再继续等待

修改OrderHystrix80的yml配置文件

```yml
feign:
  hystrix:
    enabled: true
```

主启动类上加上@EnableHystrix注解，开启Hystrix服务降级机制

```java
@SpringBootApplication
@EnableFeignClients
@EnableHystrix
public class OrderHystrixMain80{
    public static void main(String[] args){
        SpringApplication.run(OrderHystrixMain80.class,args);
    }
}
```

修改OrderHystrix80的controller层，加上兜底方法

```java
@RestController
@Slf4j
public class OrderHystrixController {

    @Resource
    private PaymentService paymentService;

    @GetMapping("/consumer/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_OK(id);
        return result;
    }

    @GetMapping("/consumer/payment/hystrix/timeout/{id}")
    @HystrixCommand(fallbackMethod = "paymentTimeOutFallbackMethod", commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
    })   //配置客户端的服务降级
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentService.paymentInfo_ERROR(id);
    }

    public String paymentTimeOutFallbackMethod(@PathVariable("id") Integer id) {
        return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";
    }

}
```

这样就完成了客户端的服务降级配置



**存在的问题：**

观察上面的代码可以发现，在OrderHystrix80端口这个客户端上，需要对每一个业务方法配置一个兜底方法，并且兜底方法与业务处理方法混合在一起，会造成代码的膨胀

```java
@RestController
@Slf4j
public class OrderHystrixController {

    @Resource
    private PaymentService paymentService;
    
    @HystrixCommand(fallbackMethod = "paymentOKFallbackMethod", commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
    })   //配置客户端的服务降级
    @GetMapping("/consumer/payment/hystrix/ok/{id}")
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        String result = paymentService.paymentInfo_OK(id);
        return result;
    }

    @GetMapping("/consumer/payment/hystrix/timeout/{id}")
    @HystrixCommand(fallbackMethod = "paymentTimeOutFallbackMethod", commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
    })   //配置客户端的服务降级
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentService.paymentInfo_ERROR(id);
    }

    public String paymentTimeOutFallbackMethod(@PathVariable("id") Integer id) {
        return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";
    }
    
    ...

}
```

解决方法：@DefaultProperties(defaultFallback = "")，配置一个全局配置方法，如果没有特殊要求的处理方法都可以使用同一个兜底方法，如果有对处理业务有特殊要求的就使用上面的方法一对一配置

```java
@RestController
@Slf4j
@DefaultProperties(defaultFallback = "payment_Global_FallbackMethod")
public class OrderHystrixController {

    @Resource
    private PaymentService paymentService;

    @GetMapping("/consumer/payment/hystrix/ok/{id}")
    @HystrixCommand   //加了@DefaultProperties属性注解，并且没有写具体方法名字，就用统一全局的
    public String paymentInfo_OK(@PathVariable("id") Integer id) {
        //int age = 10 / 0;   //模拟服务器内部异常
        String result = paymentService.paymentInfo_OK(id);
        return result;
    }

    @GetMapping("/consumer/payment/hystrix/timeout/{id}")
    @HystrixCommand(fallbackMethod = "paymentTimeOutFallbackMethod", commandProperties = {
            @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")
    })   //如果写了具体方法的名字，就按照具体方法来
    public String paymentInfo_TimeOut(@PathVariable("id") Integer id){
        return paymentService.paymentInfo_ERROR(id);
    }

    public String paymentTimeOutFallbackMethod(@PathVariable("id") Integer id) {
        return "我是消费者80,对方支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,o(╥﹏╥)o";
    }

    public String payment_Global_FallbackMethod() {
        return "Global异常处理信息，请稍后再试，/(ㄒoㄒ)/~~";
    }

}
```



**存在问题：**

虽然经过上述的配置，一定程度上解决了代码膨胀的问题，但是，仍然存在兜底方法与业务逻辑代码混在一起导致的代码混乱问题，维护起来非常麻烦

解决方法：

OrderHystrix80微服务的service层是使用OpenFeign调用cloud-payment-hystrix-8001服务中的业务逻辑方法

```java
@Component
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT")
public interface PaymentService {
    @GetMapping("/payment/hystrix/ok/{id}")
    String paymentInfo_OK(@PathVariable("id") Integer id);

    @GetMapping("/payment/hystrix/timeout/{id}")
    String paymentInfo_ERROR(@PathVariable("id") Integer id);
}
```

可以再新建一个类去实现这个接口，在新建的类中，去进行每个方法的服务降级处理，这样就无需在controller层一对一编写服务降级方法了

```java
//创建一个类实现PaymentService，对服务端的所有方法在这个类中做一次统一的降级处理，降级处理的代码就写在每个方法的方法体中
@Component
public class PaymentServiceFallback implements PaymentService {
    //当业务层这个方法调用失败或者处理超时时，会转入这个兜底类中的方法，进行服务降级处理
    @Override
    public String paymentInfo_OK(Integer id) {
        return "服务调用失败，提示来自：cloud-consumer-feign-order80";
    }

    @Override
    public String paymentInfo_ERROR(Integer id) {
        return null;
    }
}
```

并且在service接口上补全@FeignClient的属性

```java
@Component
//将统一处理服务降级的类配置到接口中
@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT", fallback = PaymentServiceFallback.class)
public interface PaymentService {
    @GetMapping("/payment/hystrix/ok/{id}")
    String paymentInfo_OK(@PathVariable("id") Integer id);

    @GetMapping("/payment/hystrix/timeout/{id}")
    String paymentInfo_ERROR(@PathVariable("id") Integer id);
}
```

演示：当payment-hystrix-8001正常启动时，orderhystrix80微服务可以正常访问；现在关闭payment8001服务，模拟服务器宕机，这样，再次访问的时候就会出现服务降级

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\feign客户端统一服务降级处理.jpg)

#### 2.7.2 服务熔断

**服务熔断与服务降级是不同的概念！**

```
1、服务调用失败会触发服务降级，降级会调用指定的fallback方法
2、服务降级一定是先调用正常的逻辑，再调用降级方法
3、假设单位次数内调用失败的次数过多，即降级次数过多，就会触发服务熔断
4、服务熔断之后，当请求再次来临时，不会去调用正常的处理请求的方法，而是直接调用fallback降级方法
5、切断对下游服务的调用就是不管发来什么请求，都跳过正常的处理逻辑直接调用fallback降级方法
```

**熔断机制的概述**

熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，
会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。
*当检测到该节点微服务调用响应正常后，恢复调用链路。*

在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，
当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。

**服务熔断的演示**

1、修改payment-hystrix-8001的service层，增加服务熔断的机制

```java
//=========服务熔断
@HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {
        @HystrixProperty(name = "circuitBreaker.enabled",value = "true"), //是否开启断路器
        @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),  //在10s内请求发出多少次会触发熔断机制
        @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"), //触发熔断机制多少ms后去尝试再一次请求，默认是5000ms
        @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"),  //失败率达到多少后开启熔断器
})  //意思是在10s内请求十次，如果失败率达到60%(即失败6次以上)，则启动服务熔断，熔断器打开10s之后，再次尝试发出请求，进而判断是否能够关闭熔断器
public String paymentCircuitBreaker(@PathVariable("id") Integer id) {
    //当id值为负数时，发出异常
    if(id < 0) {
        throw new RuntimeException("******id 不能负数");
    }
    String serialNumber = IdUtil.simpleUUID();

    return Thread.currentThread().getName()+"\t"+"调用成功，流水号: " + serialNumber;
}
```

2、在controller层中增加服务熔断的测试方法

```java
//====服务熔断
@GetMapping("/payment/circuit/{id}")
public String paymentCircuitBreaker(@PathVariable("id") Integer id) {
    String result = paymentService.paymentCircuitBreaker(id);
    log.info("****result: "+result);
    return result;
}
```

3、进行自测：输入错误的请求路径http://localhost:8001//payment/circuit/-1，多次刷新，模拟短时间内失败的请求，当达到一定次数之后，再输入正确的请求http://localhost:8001//payment/circuit/1

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Hystrix熔断机制、.jpg)

可以发现已经触发了熔断机制，正确的请求也返回了fallback降级方法的返回结果

**断路器的工作状态转换**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\熔断器状态转换.jpeg)

**断路器的工作流程：**

1、当在10s内达到了设置的请求次数`circuitBreaker.requestVolumeThreshold`

2、并且请求失败率达到了自定义的设定值`circuitBreaker.errorThresholdPercentage`

3、断路器的状态就会从CLOSE切换到OPEN

4、当断路器打开时，它会切断所有的请求访问，直接调用fallback方法

5、过了一定的时间`circuitBreaker.sleepWindowInMilliseconds`之后，断路器会尝试着放行一个请求，即所谓的HALF OPEN的状态，如果请求失败，断路器继续保持打开的状态并持续`circuitBreaker.sleepWindowInMilliseconds`时间，再次进行尝试；如果请求访问成功，则将断路器关闭，恢复链路的调用

服务熔断的所有配置，可供参考

```java
//========================All
@HystrixCommand(fallbackMethod = "str_fallbackMethod",
        groupKey = "strGroupCommand",
        commandKey = "strCommand",
        threadPoolKey = "strThreadPool",

        commandProperties = {
                // 设置隔离策略，THREAD 表示线程池 SEMAPHORE：信号池隔离
                @HystrixProperty(name = "execution.isolation.strategy", value = "THREAD"),
                // 当隔离策略选择信号池隔离的时候，用来设置信号池的大小（最大并发数）
                @HystrixProperty(name = "execution.isolation.semaphore.maxConcurrentRequests", value = "10"),
                // 配置命令执行的超时时间
                @HystrixProperty(name = "execution.isolation.thread.timeoutinMilliseconds", value = "10"),
                // 是否启用超时时间
                @HystrixProperty(name = "execution.timeout.enabled", value = "true"),
                // 执行超时的时候是否中断
                @HystrixProperty(name = "execution.isolation.thread.interruptOnTimeout", value = "true"),
                // 执行被取消的时候是否中断
                @HystrixProperty(name = "execution.isolation.thread.interruptOnCancel", value = "true"),
                // 允许回调方法执行的最大并发数
                @HystrixProperty(name = "fallback.isolation.semaphore.maxConcurrentRequests", value = "10"),
                // 服务降级是否启用，是否执行回调函数
                @HystrixProperty(name = "fallback.enabled", value = "true"),
                // 是否启用断路器
                @HystrixProperty(name = "circuitBreaker.enabled", value = "true"),
                // 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为 20 的时候，
                // 如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。
                @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"),
                // 该属性用来设置在滚动时间窗中，表示在滚动时间窗中，在请求数量超过
                // circuitBreaker.requestVolumeThreshold 的情况下，如果错误请求数的百分比超过50,
                // 就把断路器设置为 "打开" 状态，否则就设置为 "关闭" 状态。
                @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
                // 该属性用来设置当断路器打开之后的休眠时间窗。 休眠时间窗结束之后，
                // 会将断路器置为 "半开" 状态，尝试熔断的请求命令，如果依然失败就将断路器继续设置为 "打开" 状态，
                // 如果成功就设置为 "关闭" 状态。
                @HystrixProperty(name = "circuitBreaker.sleepWindowinMilliseconds", value = "5000"),
                // 断路器强制打开
                @HystrixProperty(name = "circuitBreaker.forceOpen", value = "false"),
                // 断路器强制关闭
                @HystrixProperty(name = "circuitBreaker.forceClosed", value = "false"),
                // 滚动时间窗设置，该时间用于断路器判断健康度时需要收集信息的持续时间
                @HystrixProperty(name = "metrics.rollingStats.timeinMilliseconds", value = "10000"),
                // 该属性用来设置滚动时间窗统计指标信息时划分"桶"的数量，断路器在收集指标信息的时候会根据
                // 设置的时间窗长度拆分成多个 "桶" 来累计各度量值，每个"桶"记录了一段时间内的采集指标。
                // 比如 10 秒内拆分成 10 个"桶"收集这样，所以 timeinMilliseconds 必须能被 numBuckets 整除。否则会抛异常
                @HystrixProperty(name = "metrics.rollingStats.numBuckets", value = "10"),
                // 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为 false, 那么所有的概要统计都将返回 -1。
                @HystrixProperty(name = "metrics.rollingPercentile.enabled", value = "false"),
                // 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。
                @HystrixProperty(name = "metrics.rollingPercentile.timeInMilliseconds", value = "60000"),
                // 该属性用来设置百分位统计滚动窗口中使用 “ 桶 ”的数量。
                @HystrixProperty(name = "metrics.rollingPercentile.numBuckets", value = "60000"),
                // 该属性用来设置在执行过程中每个 “桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，
                // 就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个 “桶 ”中发生了500次执行，
                // 那么该 “桶” 中只保留 最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。
                @HystrixProperty(name = "metrics.rollingPercentile.bucketSize", value = "100"),
                // 该属性用来设置采集影响断路器状态的健康快照（请求的成功、 错误百分比）的间隔等待时间。
                @HystrixProperty(name = "metrics.healthSnapshot.intervalinMilliseconds", value = "500"),
                // 是否开启请求缓存
                @HystrixProperty(name = "requestCache.enabled", value = "true"),
                // HystrixCommand的执行和事件是否打印日志到 HystrixRequestLog 中
                @HystrixProperty(name = "requestLog.enabled", value = "true"),
        },
        threadPoolProperties = {
                // 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量
                @HystrixProperty(name = "coreSize", value = "10"),
                // 该参数用来设置线程池的最大队列大小。当设置为 -1 时，线程池将使用 SynchronousQueue 实现的队列，
                // 否则将使用 LinkedBlockingQueue 实现的队列。
                @HystrixProperty(name = "maxQueueSize", value = "-1"),
                // 该参数用来为队列设置拒绝阈值。 通过该参数， 即使队列没有达到最大值也能拒绝请求。
                // 该参数主要是对 LinkedBlockingQueue 队列的补充,因为 LinkedBlockingQueue
                // 队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。
                @HystrixProperty(name = "queueSizeRejectionThreshold", value = "5"),
        }
)
public String strConsumer() {
    return "hello 2020";
}
public String str_fallbackMethod()
{
    return "*****fall back str_fallbackMethod";
}
```

### 2.8 服务网关

**什么是GateWay**

Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。
Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等

SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。

**Spring Cloud GateWay的功能**

+ 反向代理
+ 鉴权
+ 流量控制
+ 熔断
+ 日志监控
+ ......

微服务架构中网关的位置：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关的位置.jpeg)



**GateWay的三大核心概念**

+ **路由**：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

  类似计算机网络中的路由，进行请求转发

+ **断言**：参考的是Java8的java.util.function.Predicate
  开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由转发

  应该是一个匹配机制，判断发送到网关的请求是否与路由中的请求路径相一致，如果一致则返回true

+ **过滤**：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

  类似于SpringMVC中的拦截器，拦截请求，查看是否放行或者在请求结束之后再做一些后续处理

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关架构.jpeg)

**网关的初步搭建**

1、新建一个模块，springcloud-gateway-9527

2、pom文件，导入的时候需要注意，网关不能导入spring-boot-starter-web的依赖，因为会产生jar冲突，springcloud的网关依赖的是webflux的响应式编程，并不支持传统的web依赖

```xml
<dependencies>
    <!--gateway-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <!--eureka-client-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <dependency>
        <groupId>com.SpringCloud</groupId>
        <artifactId>springcloud-api-commons</artifactId>
        <version>${project.version}</version>
    </dependency>
    <!--一般基础配置类-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

3、修改配置文件

```yml
server:
  port: 9527

eureka:
  instance:
    hostname: springcloud-gateway-service
  client:
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka
spring:
  application:
    name: springcloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001          #匹配后提供服务的路由地址
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
```

4、测试，注意访问路径是localhost:9527/...

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关测试.jpg)

5、另一种网关的配置  --- 自己编写配置类，仅供参考

```java
@Configuration
public class GateWayConfig {
    @Bean
    public RouteLocator routeLocator(RouteLocatorBuilder builder){
        RouteLocatorBuilder.Builder routes = builder.routes();
        routes.route("path_route_cloud_1",   //路由id
                r -> r.path("/guonei").uri("http://news.baidu.com")).build();   //lambda表达式，断言匹配
        return routes.build();
    }
}
```

测试：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关类配置.jpg)

**动态路由**

默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能

修改网关的yml配置

```yml
server:
  port: 9527

eureka:
  instance:
    hostname: springcloud-gateway-service
  client:
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka
spring:
  application:
    name: springcloud-gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由
      routes:
        - id: payment_routh #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          #uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://CLOUD-PAYMENT-SERVICE
          predicates:
            - Path=/payment/get/**         # 断言，路径相匹配的进行路由

        - id: payment_routh2 #payment_route    #路由的ID，没有固定规则但要求唯一，建议配合服务名
          #uri: http://localhost:8001          #匹配后提供服务的路由地址
          uri: lb://CLOUD-PAYMENT-SERVICE     #lb: load balance，表示启用网关的负载均衡
          predicates:
            - Path=/payment/lb/**         # 断言，路径相匹配的进行路由
```

测试：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关负载均衡测试1.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\网关负载均衡测试2.jpg)

**GateWayFilter：网关过滤器**



### 2.9 配置中心

#### 2.9.1 为什么会出现配置中心？

微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。

现在部署的微服务遵循几个固定步骤：

+ 新建工程
+ 改pom.xml
+ 创建application.yml，编写配置文件
+ 编写主启动类
+ 编写相应的业务逻辑

随着应用的逐渐扩大，微服务的数量也会越来越多，在现在这种情况下，每一个微服务单独拥有一个配置文件，维护自己的配置，但不难发现，就之前的微服务配置来说，有好多配置都是相似的，比如需要注册的服务中心，以及最常用的MySQL连接配置，如果之后需要更改这些配置，那么就需要修改每一个配置文件，当微服务数量很多时显得十分麻烦

#### 2.9.2 什么是配置中心

SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。

与服务注册中心相似，SpringCloud Config也分为服务端和客户端

+ 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口

+ 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。

**SpringCloud Config的作用**

+ 集中管理配置文件

+ 不同环境不同配置，动态化的配置更新，分环境部署

  比如可以将相同的配置部署在测试环境下，生产环境下以及发布环境等等，不需要在每一个微服务中维护这样的配置

+ 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息

+ 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置

#### 2.9.3 搭建SpringCloud Config Server

准备工作：

需要在Github账号下新建一个仓库，创建一些测试的配置文件，克隆到本地库

1、新建工程

2、修改pom.xml文件

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

```

3、修改application.yml配置文件

```yml
server:
  port: 3344

spring:
  application:
    name:  cloud-config-center #注册进Eureka服务器的微服务名
  cloud:
    config:
      server:
        git:
          uri: #自己github上仓库的连接 #GitHub上面的git仓库名字
          username:  #如果使用https就需要验证用户名和密码 
          password: 
          #搜索目录
          search-paths:
            - springcloud-config
      ####读取分支
      label: master

#服务注册到eureka地址
eureka:
  client:
    service-url: defaultZone: http://localhost:7001/eureka
```

4、编写主启动类

```java
@SpringBootApplication
@EnableConfigServer   //标记这是一个ConfigServer
public class ConfigCenterMain3344{
    public static void main(String[] args) {
            SpringApplication.run(ConfigCenterMain3344.class, args);
    }
}
```

5、最后测试http://config-3344.com:3344/master/config-dev.yml，本人没有测试成功，不知道为什么...

#### 2.9.4 搭建SpringCloud Config Client

上面搭建的是服务配置中心的服务端从github上获取统一的配置，现在需要配置服务注册中心的客户端，来获取服务端上的配置

1、新建工程

2、修改pom.xml

```xml
<dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

3、修改配置文件

平常写配置文件的时候都是在application.yml中修改，此次修改需要在bootstrap.yml中修改

**什么是bootstrap.yml**

applicaiton.yml是用户级的资源配置项
bootstrap.yml是系统级的，优先级更加高

Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的`Application Context`的父上下文。初始化的时候，`Bootstrap Context`负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的`Environment`。

`Bootstrap`属性有高优先级，默认情况下，它们不会被本地配置覆盖。 `Bootstrap context`和`Application Context`有着不同的约定，所以新增了一个`bootstrap.yml`文件，保证`Bootstrap Context`和`Application Context`配置的分离。

要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml

我的理解是需要先加载全局配置，因为这部分是每个微服务都有并且不会变的，application.yml中是每一个微服务特有的部分

```yml
server:
  port: 3355

spring:
  application:
    name: config-client
  cloud:
    #Config客户端配置
    config:
      label: master #分支名称
      name: config #配置文件名称
      profile: dev #读取后缀名称   上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml
      uri: http://localhost:3344 #配置中心地址k

#服务注册到eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka
```

4、编写主启动类

```java
@SpringBootApplication
@EnableEurekaClient
public class ConfigClient3355 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigClient3355.class, args);
    }
}
```

5、编写业务逻辑，这里的业务为测试方便就简单写

```java
@RestController
@Slf4j
public class ConfigClientController {
    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/configInfo")
    public String getConfigInfo() {
        return configInfo;
    }
}
```

测试：http://localhost:3355/configInfo访问配置中心服务端获取配置

**存在问题**

+ 假设现在运维在github上修改了某些配置，配置中心服务端能够立刻获得这些修改的配置
+ 但配置中心客户端却不能立刻获取，需要重启服务才能获取到最新的数据
+ 如果是这样，当客户端一多，每一次修改就需要重启多个客户端，十分的浪费时间

**解决方法：**动态刷新

在客户端的pom文件中引入actuator

修改yml文件，暴露监控端口

```yml
# 暴露监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

在客户端业务类的控制层上添加@RefreshScope注解，再次测试，发现客户端还是没能获取新修改的配置

这里就还需要另一步，需要运维工程师手动发送一个post请求去提醒客户端刷新，使用windows的curl进行测试，给客户端发送一个post请求

```
curl -X POST "http://localhost:3355/actuator/refresh"
```

这时再刷新客户端，就能够获得最新的配置了

**继续优化**

如果有多个客户端，那么就需要发送多个刷新的post请求，这样其实还是很麻烦的

可以在修改配置的时候，发送一个广播消息，提醒每一个客户端去刷新



### 2.10 服务总线

根据上面配置中心存在的问题：当github上的资源更新了之后，需要第一时间让配置中心的服务端知道并广播给配置中心的客户端，但这样的一个操作需要运维人员手工发送post请求，随着客户端的增加，操作起来也很麻烦

现在使用Spring Cloud Bus 配合 Spring Cloud Config 可以实现配置的动态刷新。

#### 2.10.1 Spring Cloud Bus介绍

Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。
Spring Clud Bus目前支持RabbitMQ和Kafka。

Spring Cloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。

bus的广播设计方式有两种：

1. 第一种是先将post请求发送给一个配置中心的客户端，然后由客户端向总线发送消息，再由总线将这个消息发送给剩余的客户端

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\SpringCloud Bus.jpeg)

2. 将post请求发送给服务端，由服务端通知总线，广播给客户端

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\springcloud bus2.jpeg)

在这两种设计模式中，会选择第二种

第一种设计模式的缺陷：

+ 客户端不再是平等的了，先将post请求发送给一个客户端A，那么这个A就需要承担接收请求和发送给Bus的职责，会加重客户端的负担，并且，如果这个客户端宕机了，整个广播也会失去效果

第二种设计模式就不会遇见这样的问题，因为这个接受请求的职责由服务端承担，并且各个客户端的地位也是平等的

#### 2.10.2 Bus的使用



### 2.11 Spring Cloud Stream





## 三、Springcloud Alibaba

### 3.1 Nacos

#### 3.1.1简介

Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。

Nacos: Dynamic Naming and Configuration Service

Nacos = Eureka+Config +Bus

**Nacos能干什么**

+ 代替Springcloud eureka作为服务注册中心
+ 代替Springcloud config作为服务配置中心

#### 3.1.2 Nacos作为服务注册中心

新建一个Module -- springcloud-alibaba-provider-payment9001和9002作为服务提供者注册进nacos注册中心

**pom.xml**

```xml
<dependencies>
        <!--SpringCloud ailibaba nacos -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <!-- SpringBoot整合Web组件 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--日常通用jar包配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>
```

**application.yml**

```yml
server:
  port: 9001
spring:
  application:
    name: nacos-payment-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848   #配置nacos地址


management:
  endpoints:
    web:
      exposure:
        include: '*'
```

**主启动类和controller层**

```java
@SpringBootApplication
@EnableDiscoveryClient
public class AlibabaPaymentMain9001 {
    public static void main(String[] args) {
        SpringApplication.run(AlibabaPaymentMain9001.class, args);
    }
}

@RestController
public class PaymentController {

    @Value("${server.port}")
    private String serverPort;

    @GetMapping("/payment/nacos/{id}")
    public String getPayment(@PathVariable("id") Integer id){
        return "nacos registry, serverPort: "+ serverPort + "\t id" + id;
    }

}
```

启动步骤：

1. 首先要启动nacos，在nacos的安装目录下的bin文件夹中，打开cmd命令行，输入startup.cmd启动nacos

   ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos启动.jpg)

2. 浏览器界面输入localhost:8848/nacos访问nacos图形化界面，默认登录账号密码均为guest

   ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos服务界面.jpg)

   

3. 启动两个微服务，刷新nacos界面，可以看到服务已经注册进nacos中了

**创建服务消费者调用nacos中的微服务**

pom.xml，这里需要说明的一点是nacos2021版本已经不支持ribbon负载均衡需要另外导入loadbalanced的jar包

```xml
<dependencies>
    <!--SpringCloud ailibaba nacos -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
	<!--另外导入loadbalanced包-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    </dependency>

    <!-- 引入自己定义的api通用包，可以使用Payment支付Entity -->
    <dependency>
        <groupId>com.SpringCloud</groupId>
        <artifactId>springcloud-api-commons</artifactId>
        <version>${project.version}</version>
    </dependency>
    <!-- SpringBoot整合Web组件 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!--日常通用jar包配置-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

</dependencies>
```

application.yml文件

```yml
server:
  port: 83


spring:
  application:
    name: nacos-order-consumer
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848


#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)
service-url:
  nacos-user-service: http://nacos-payment-provider
```

配置类和控制层方法

```java
@Configuration
public class ApplicationContextConfig {

    @Bean
    @LoadBalanced  //负载均衡
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }
}

@RestController
public class OrderController {

    @Autowired
    private RestTemplate restTemplate;

    @Value("${service-url.nacos-user-service}") //获取微服务提供者的访问路径
    private String serverURL;

    @GetMapping("/consumer/payment/nacos/{id}")
    public String paymentInfo(@PathVariable("id") Long id) {
        return restTemplate.getForObject(serverURL + "/payment/nacos/" + id, String.class);
    }

}
```

启动服务消费者，访问payment

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos消费者1.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos消费者2.jpg)

#### 3.1.3 Nacos作为服务配置中心

nacos本身就是一个服务配置中心的服务端，所以直接创建服务配置中心的客户端

**pom.xml**

```xml
<dependencies>
    <!--nacos-config-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    <!--nacos-discovery-->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <!--web + actuator-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <!--一般基础配置-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

**配置文件：bootstrap.yml，application.yml**

```yml
#bootstrap.yml，springboot机制下优先加载bootstrap.yml配置文件再加载applicaiton.yml
# nacos配置
server:
  port: 3377

spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yml   #读取指定yaml格式的配置文件
        #group: DEV_GROUP
        #namespace: c50ff2ae-67bb-4419-a4bc-aa751d1eac52
        
#application.yml
spring:
  profiles:
    #active: info
  	#active: test #测试环境
    active: dev # 表示开发环境
```

**主启动类和控制类**

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ConfigClientMain3377 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigClientMain3377.class, args);
    }
}

@RestController
@RefreshScope  //支持动态刷新
public class ConfigClientController {

    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/config/info")
    public String getConfigInfo(){
        return configInfo;
    }
}
```

**在nacos中添加配置文件**

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos添加配置文件.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos添加配置文件2.jpg)



**nacos中配置文件的命名规则**

官网上的说明：

在 Nacos Spring Cloud 中，`dataId` 的完整格式如下：

```plain
${prefix}-${spring.profiles.active}.${file-extension}
```

- `prefix` 默认为 `spring.application.name` 的值，也可以通过配置项 `spring.cloud.nacos.config.prefix`来配置。
- `spring.profiles.active` 即为当前环境对应的 profile，详情可以参考 [Spring Boot文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles)。 **注意：当 `spring.profiles.active` 为空时，对应的连接符 `-` 也将不存在，dataId 的拼接格式变成 `${prefix}.${file-extension}`**
- `file-exetension` 为配置内容的数据格式，可以通过配置项 `spring.cloud.nacos.config.file-extension` 来配置。目前只支持 `properties` 和 `yaml` 类型。

通过示例的配置文件

```yml
#bootstrap.yml
spring:
  application:
    name: nacos-config-client   #对应${prefix}
  cloud:
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yml   #读取指定yaml格式的配置文件  #对应${file-extension}
        
        
#application.yml
spring:
  profiles:
    active: dev # 表示开发环境  #对应${spring.profiles.active}
```

在nacos中创建配置文件时，需要严格按照上面的命名规则对配置文件进行命名，否则就读取不到配置信息

另外Nacos会记录配置文件的历史版本默认保留30天，此外还有一键回滚功能，回滚操作将会触发配置更新



**Nacos的多项目多环境配置文件管理**

实际开发中，通常一个系统会准备：dev开发环境、test测试环境、prod生产环境等

一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境......

nacos对不同微服务下的不同环境配置文件进行管理

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos配置管理.jpeg)

nacos的管理分为：namespace，group，dataId，相当于java中的报名 + 类名

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\三者的关系.jpeg)

默认情况：
Namespace=public，Group=DEFAULT_GROUP, 默认Cluster是DEFAULT

+ dataId方案：指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置

+ group方案：通过Group实现环境区分

  ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos配置管理--group.jpeg)

外加bootstrap.yml配置文件中的配置：

```yml
spring:
  application:
    name: nacos-config-client
  cloud:
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yml   #读取指定yaml格式的配置文件
        group: DEV_GROUP  #到具体的group中取配置文件
```

+ namespace方案：

  ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos配置管理--namespace1.jpeg)

  新建namespace之后，nacos会自动生成一个命名空间id，使用命名空间id来访问对应的namespace，需要在bootstrap.yml中添加配置：

  ```yml
  spring:
    application:
      name: nacos-config-client
    cloud:
        config:
          server-addr: localhost:8848 #Nacos作为配置中心地址
          file-extension: yml   #读取指定yaml格式的配置文件
          group: DEV_GROUP
          namespace: c50ff2ae-67bb-4419-a4bc-aa751d1eac52  #对应的namespaceId
  ```

  

总体来说可以使用namespace来区分每一个微服务，使用group来区分具体的一种配置环境，方便管理



#### 3.1.4 Nacos集群配置

在生产环境中，使用nacos集群配置来保证高可用,一般的nacos集群建议配置在linux系统下

> Nacos支持的三种部署模式
>
> + 单机模式：用于测试和单机应用
> + 集群模式：用于生产环境，确保高可用
> + 多集群模式：用于多数据中心场景

nacos集群架构图：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos集群架构.jpeg)

默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。



**Nacos持久化文件配置**

Nacos默认自带的是嵌入式数据库derby，修改配置文件的内容，可以将数据库配置从derby切换到MySQL下

1. 在nacos的安装目录下，进入nacos-server-1.4.3\nacos\conf目录下找到sql脚本（nacos-mysql.sql），粘贴到MySQL数据库中执行，使得生成的表在nacos_config数据库下

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos_MySQL表结构.jpg)



2. nacos-server-1.4.3\nacos\conf目录下找到application.properties，添加相关配置

   ```properties
   ############################################
   spring.datasource.platform=mysql
    
   db.num=1
   db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&&serverTimezone=UTC
   db.user=root
   db.password=123456
   ```

3. 启动nacos，可以看到之前设置的配置文件都清空了，新建配置文件之后，配置文件的信息会出现在MySQL中

   ![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos_配置文件_mysql.jpg)

   

**Linux下安装nacos**

首先需要安装java8环境，在usr/local下新建jdk目录

```shell
#在usr/local目录下新建jdk目录
mkdir /usr/local/jdk
#进入usr/local/jdk目录
cd /usr/local/jdk
#使用yum命令安装下载java-1.8.0
yum install java-1.8.0-openjdk* -y
#安装完成之后使用java -version检查是否安装成功
java -verison
#如果出现一下信息表示安装成功
openjdk version "1.8.0.322"
OpenJDK Runtime Environment (build 1.8.0_322-b06)
OpenJDK 64-bit Server VM (build 25.322-b06, mixed mode)
```

安装nacos

```shell
#在/opt文件夹下下载
cd /opt
#使用wget命令从网上下载nacos安装包
wget https://github.com/alibaba/nacos/releases/download/1.4.3/nacos-server-1.4.3.tar.gz
#使用tar命令解压
tar -zxvf nacos-server-1.4.3.tar.gz
```

修改nacos配置，在测试时，使用单机模式启动nacos，到时候要用集群时再配置回去

```shell
#进入nacos目录下的bin目录
cd /opt/nacos/bin
#使用vim命令打开并修改startup.sh脚本
vim startup.sh
#修改mode为standalone，:wq!保存并退出
export MODE="standalone"
:wq!
```

保存退出后，使用命令sh startup.sh启动nacos，可以在opt/nacos/logs文件夹下的start.out日志中查看启动情况

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos_linux启动.jpg)

出现上面所示的界面就表示启动成功

在linux虚拟机中访问nacos网站

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos启动成功.jpg)

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos_linux界面.jpg)

都成功之后，在linux系统中也能够使用nacos了

**Linux下的nacos集群配置**

首先需要在linux下安装mysql8.0.27版本，可以让nacos配置文件迁移到mysql数据库中，再按照上面在windows系统中数据库迁移的步骤，将nacos的数据库迁移至mysql中

接下来集群配置

```shell
# 修改nacos目录下的配置文件 -- cluster.conf
cd /opt/nacos/conf
#备份一份初始的配置文件
cp cluster.conf cluster.conf.init
#使用vim命令修改cluster.conf文件
vim cluster.conf
192.168.43.218:3333
192.168.43.218:4444
192.168.43.218:5555
#修改完成后保存退出，进入nacos/bin目录下
cd ../bin
#使用sh startup.sh命令启动
sh startup.sh
#如果出错可以使用cat命令查看log文件获取错误信息
```

接下来配置nginx

```shell
#进入nginx安装目录下修改配置文件
cd /etc/nginx/conf.d
cp default.conf default.conf.init
vim default.conf
#添加
upstream cluster{
        server 127.0.0.1:3333;
        server 127.0.0.1:4444;
        server 127.0.0.1:5555;
    }
server {
        listen       1111;
        server_name  localhost;
        #charset koi8-r;
        #access_log  logs/host.access.log  main;
        location / {
            #root   html;
            #index  index.html index.htm;
            #修改这部分
            proxy_pass http://cluster;
        }
#保存退出后启动nginx
cd /usr/sbin
#启动nginx
./nginx -c /etc/nginx/nginx.conf
```

集群启动完毕之后可以测试访问http:192.168.43.218:1111/nacos/#/login

最后系统形成的一个高可用集群架构：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\nacos集群架构-nginx.jpeg)

### 3.2 Sentinel

#### 3.2.1 简介

Sentinel是轻量级的流量控制，熔断降级的Java库

Sentinel的作用：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\Sentinel作用.jpeg)

与Netflix的Hystrix相似可以对服务进行监控，防止服务器雪崩，以及在流量高峰进行服务降级和服务熔断

Sentinel分为两个部分：

+ 核心库：不依赖于任何框架，能够运行于所有的Java运行时环境，同时对Dubbo，SpringCloud等框架也有较好的支持
+ 控制台：基于Springboot开发，打包后可以直接运行，不需要额外的Tomcat等应用容器

从github上下载下来之后是一个jar包，可以直接使用java -jar命令运行

Sentinel默认的端口是8080，启动时要确保8080端口不被占用，运行之后使用http://localhost:8080访问sentinel界面

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel界面.jpg)

#### 3.2.2 服务管理

**新建一个Module**

**pom.xml**

```xml
<dependencies>
        <!--SpringCloud ailibaba nacos -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到-->
        <dependency>
            <groupId>com.alibaba.csp</groupId>
            <artifactId>sentinel-datasource-nacos</artifactId>
        </dependency>
        <!--SpringCloud ailibaba sentinel -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
        </dependency>
        <!--openfeign-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <!-- SpringBoot整合Web组件+actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <!--日常通用jar包配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>4.6.3</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

**application.yml**

```yml
server:
  port: 8401

spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        #Nacos服务注册中心地址
        server-addr: localhost:8848
    sentinel:
      transport:
        #配置Sentinel dashboard地址
        dashboard: localhost:8080
        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
        port: 8719

management:
  endpoints:
    web:
      exposure:
        include: '*'
```

模块创建完毕之后启动微服务，再刷新sentinel会发现并没有服务显示，这是因为sentinel采用懒加载机制，需要执行一次访问之后才能显示服务信息，访问再controller层设置的路径：http://localhost:8401/testA，之后可以发现界面显示了一些服务信息

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel监控.jpg)

#### 3.2.3 sentinel的流控规则

sentinel的流控设置界面：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel直接快速失败.jpg)

+ 资源名：唯一名称，即要监控的请求路径
+ 针对来源：Sentinel可以针对调用者进行限流，填写调用者微服务的名称，默认是default，即不区分来源
+ 阈值类型 / 单机阈值：
  + QPS：每秒钟请求数，当调用该API的QPS达到阈值时，进行限流
  + 线程数：当调用该API的线程数达到阈值时，进行限流
+ 是否集群：是否是集群模式
+ 流控模式
  + 直接：当调用API达到限流的条件时，直接限流
  + 关联：当关联的资源达到阈值时，就限流自己
  + 链路：只记录指定链路上的流量，指定请求从入口资源进来的流量，如果达到阈值，则进行限流
+ 流控效果：
  + 快速失败：直接失败，返回信息
  + warm up：根据codeFactor（冷加载因子，默认为3）的值，从设定阈值 / 3的限制开始，经过设定的预热时长，才到达设置的QPS阈值
  + 排队等待：匀速排队，让请求以匀速通过，阈值类型必须设置为QPS

**直接快速失败**

配置：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel直接快速失败.jpg)

效果：当方位/testA路径之后，迅速多次点击刷新，模拟在1s之内的多次访问，设置的阈值是1s内访问1次，即超过1s会进行限流

结果返回Blocked by Sentinel (flow limiting)

**关联**

配置：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel关联快速失败.jpg)

当关联的资源访问达到限制，就将自己限流，就比如支付接口关联商品下单接口，当商品下单接口的访问量太多，那么支付接口也应该相应的进行限流措施

**流控效果 --- 预热**

配置：

![](C:\Users\86198\Desktop\JavaEE\SpringCloud\image\sentinel预热.jpg)

此时设置的阈值是10，预热的意思就是，当每秒访问达到 10 / coldFactor时，就进行限流，这里就是每秒访问达到3次，因为coldFactor默认值为3，然后缓慢增加阈值，3s（预热时长）之后达到单机阈值后限流

这是为了防止当系统长期处于低访问量的情况下，流量突然增加，直接把系统拉升到高水位而导致系统瘫痪，通过冷启动让通过的流量缓慢加载，在一定时间内逐渐上升到阈值，避免系统被压垮

比如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。
